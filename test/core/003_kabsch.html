<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
//#region IMPORTS
import useThreeWebGL2, { useDarkScene, useVisualDebug, THREE } from '../_lib/useThreeWebGL2.js';
import useTransformControl  from '../_lib/useTransformControl.js';
import facedCube            from '../_lib/meshes/facedCube.js';
//#endregion

//#region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {
    gizmo : useTransformControl( App ).useAxes(),
    ref : [ [-1,0,-1], [-1,0,1], [1,0,1], [1,0,-1] ],
    tar : [ [-2,0,-2], [-2,0,2], [2,0,2], [2,0,-2] ],
    sel : 3,
};

Ref.gizmo.onMove = p=>{
    Ref.solver.tarPoints[ Ref.sel ] = p;
    // Ref.test.pointsRef[ Ref.sel ] = p;
    run();
};

// https://en.wikipedia.org/wiki/Kabsch_algorithm
// https://zpl.fi/aligning-point-patterns-with-kabsch-umeyama-algorithm/
// https://gist.github.com/azlen/4f1fa5392e43510205d8074803b9a5de
// https://github.com/zalo/MathUtilities
// https://zalo.github.io/blog/kabsch/
// https://fulkast.medium.com/the-kabsch-algorithm-8e858b3f5c53
// https://github.com/zalo/MathUtilities/blob/master/Assets/Kabsch/Kabsch.cs#L45

// https://zalo.github.io/assets/js/Kabsch/Kabsch.js

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 0, 50, 10 );
    Debug = await useVisualDebug( App );
    Debug.pnt.useDepth( true );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.cube   = facedCube( null, 2 );
    App.scene.add( Ref.cube );

    Ref.solver = new Kabsch();
    Ref.solver
        .setReferences( Ref.ref )
        .setTargets( Ref.tar );

    Ref.gizmo.setPos( Ref.tar[Ref.sel] );

    // Ref.test = new KabschEnvironment();

    // let dt = 0.014799999952316284 * 82;

    // let q = new Quat().fromAxisAngle( [0,1,0], Math.PI * 0.3 * dt );
    // for( let i=0; i < 4; i++ ){
    //     const v = new Vec3().fromQuat( q, Ref.test.pointsRef[ i ] );
    //     Ref.test.pointsRef[ i ] = v;
    // }

    run();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // App.renderLoop();
    App.createRenderLoop( onPreRender ).start();
});

let cnt = 0;
window.addEventListener( 'keydown', e=>{
    if( e.key >= 1 && e.key <=4 ){
        Ref.sel = parseInt( e.key ) - 1;
        Ref.gizmo.setPos( Ref.solver.tarPoints[ Ref.sel ] );
    }

    // let dt = 0.014799999952316284;
    // let q = new Quat().fromAxisAngle( [0,1,0], Math.PI * 0.3 * dt );
    // for( let i=0; i < 4; i++ ){
    //     const v = new Vec3().fromQuat( q, Ref.test.pointsRef[ i ] );
    //     Ref.test.pointsRef[ i ] = v;
    // }

    // console.log( cnt++ );
    // run();
})

function run(){
    // console.log( 'run' );
    Debug.pnt.reset();
    Debug.ln.reset();

    // Ref.test.kabschPoints();
    // Ref.cube.position.fromArray( Ref.test.translation );
    // Ref.cube.quaternion.fromArray( Ref.test.rotation );

    Ref.solver.compute();
    Ref.cube.position.fromArray( Ref.solver.translation );
    Ref.cube.quaternion.fromArray( Ref.solver.rotation );

    const pnts = Ref.solver.getComputedPoints( false );
    for( let i=0; i < 4; i++ ){
        Debug.pnt.add( pnts[i], 0xffff00, 10, 6 );
        Debug.pnt.add( Ref.solver.tarPoints[i], 0x00ffff, 8 );
        Debug.ln.add(
            pnts[i],
            Ref.solver.tarPoints[i],
            0xffff00,
            0x00ffff,
        );
    }

    // for( let p of pnts ){
    //     Debug.pnt.add( p, 0xffff00, 10, 6 );
    // }

    // for( let p of Ref.solver.tarPoints ){
    //     Debug.pnt.add( p, 0x00ffff, 8 );
    // }

    Debug.pnt._updateGeometry();
    Debug.ln._updateGeometry();
}

function onPreRender( dt, et ){
    // let q = new Quat().fromAxisAngle( [0,1,0], Math.PI * 0.3 * dt );
    
    // for( let i=0; i < 4; i++ ){
    //     const v = new Vec3().fromQuat( q, Ref.solver.tarPoints[ i ] );
    //     Ref.solver.tarPoints[ i ] = v;
    // }

    // for( let i=0; i < 4; i++ ){
    //     const v = new Vec3().fromQuat( q, Ref.test.pointsRef[ i ] );
    //     Ref.test.pointsRef[ i ] = v;
    // }

    // run();
}
//#endregion

import { Vec3, Quat } from '@oito/oop';

class Kabsch{
    // #region MAIN
    refPoints       = [];         // Reference points
    refOffset       = [];         // Reference points offset from centroid
    refScale        = 1;
    refCenter       = [];         // Centroid of reference points
    tarPoints       = [];         // Target Points
    iterations      = 25;         // 9 for simple mapping, 20+ for more 360deg stability for rotation compute

    covariance      = [ [0,0,0], [0,0,0], [0,0,0] ];    // Matrix to help compute rtation

    // Final outputs of compute
    rotation        = new Quat();
    translation     = new Vec3();
    scale           = 1;
    constructor(){}
    // #endregion

    // #region SETTERS / GETTERS
    setReferences( ary ){
        // Precompute Reference center
        this.refCenter = [0,0,0];
        this._centroid( ary, this.refCenter );

        // Reset references data
        this.refPoints.length = 0;
        this.refOffset.length = 0;
        this.refScale         = 0;

        let off;
        for( const i of ary ){
            // Copy data, do not want to keep references
            this.refPoints.push( [ i[0], i[1], i[2] ] );
            
            // Precompute offset & scale
            off = [ 
                i[0] - this.refCenter[0], 
                i[1] - this.refCenter[1], 
                i[2] - this.refCenter[2],
            ];

            this.refScale += Vec3.len( off );
            this.refOffset.push( off );
        }

        return this;
    }

    setTargets( ary ){
        for( const i of ary ) this.tarPoints.push( i );
        return this;
    }

    getComputedPoints( incScale=false ){
        const rtn = [];
        
        for( let i of this.refOffset ){
            const v = new Vec3();

            v.fromQuat( this.rotation, i )
            if( incScale ) v.scale( this.scale );
            v.add( this.translation );

            rtn.push( v );
        }

        return rtn;
    }
    // #endregion

    // #region HELPERS
    _centroid( ary, out=[0,0,0] ){
        for( const i of ary ){
            out[0] += i[0];
            out[1] += i[1];
            out[2] += i[2];
        }

        out[0] /= ary.length;
        out[1] /= ary.length;
        out[2] /= ary.length;

        return out;
    }
    // #endregion

    // #region METHODS
    compute(){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Compute target centoid & offsets
        const tarCenter = this._centroid( this.tarPoints );
        const tarOffset = new Array( this.tarPoints.length );
        let   tarScale  = 0;

        for( let i=0; i < this.tarPoints.length; i++ ){
            tarOffset[i] = [
                this.tarPoints[i][0] - tarCenter[0], 
                this.tarPoints[i][1] - tarCenter[1], 
                this.tarPoints[i][2] - tarCenter[2],
            ];

            tarScale += Vec3.len( tarOffset[i] );
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
        // Compute Rotation 
        this.transposeMult( this.refOffset, tarOffset );    // Calculate the 3x3 Cross-Covariance Matrix
        this.rotation.copy( this.extractRotation() );       // Compute quaternion from covariance
        
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
        // Translation and Scale
        
        this.translation.fromSub( tarCenter, this.refCenter );
        this.scale = tarScale / this.refScale;
    }
    // #endregion 
    
    // #region MATHS
    transposeMult( lft, rit ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Reset Matrix
        const c = this.covariance;// = [ [0,0,0], [0,0,0], [0,0,0] ];
        for( let i of c ){ 
            i[0] = 0; 
            i[1] = 0; 
            i[2] = 0;
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Compute Matrix
        let l;
        let r;
        for( let i=0; i < lft.length; i++ ) {
            l = lft[i];
            r = rit[i];

            c[0][0] += l[0] * r[0];
            c[1][0] += l[1] * r[0];
            c[2][0] += l[2] * r[0];
            
            c[0][1] += l[0] * r[1];
            c[1][1] += l[1] * r[1];
            c[2][1] += l[2] * r[1];

            c[0][2] += l[0] * r[2];
            c[1][2] += l[1] * r[2];
            c[2][2] += l[2] * r[2];

            // c[0][0] += r[0] * t[0];
            // c[1][0] += r[1] * t[0];
            // c[2][0] += r[2] * t[0];
            
            // c[0][1] += r[0] * t[1];
            // c[1][1] += r[1] * t[1];
            // c[2][1] += r[2] * t[1];

            // c[0][2] += r[0] * t[2];
            // c[1][2] += r[1] * t[2];
            // c[2][2] += r[2] * t[2];

            // c[0][0] += t[0][0] * r[0][0];
            // c[0][0] += t[1][0] * r[1][0];
            // c[0][0] += t[2][0] * r[2][0];
        }

        // for (let i = 0; i < 3; i++) {               //i is the row in this matrix
        //     for (let j = 0; j < 3; j++) {             //j is the column in the other matrix
        //         for (let k = 0; k < lft.length; k++) { //k is the column in this matrix
        //             c[i][j] += lft[k][i] * rit[k][j];
        //             // c[i][j] += offRef[k][i] * offTar[k][j];
        //         }
        //     }
        // }

    }

    // https://animation.rwth-aachen.de/media/papers/2016-MIG-StableRotation.pdf
    // Quaternion Torque decomposition : Iteratively apply torque to the basis using Cross products ( in place of SVD )
    // NOTE: Depending on the application, iteration will need to be increased. For regular mapping 9 seems to work
    // but if trying to match rotation perfectly in a 360 rotation animation, over 20 works better.
    extractRotation( iter=this.iterations ){
        const c     = this.covariance;
        const qx    = new Vec3();   // Quaternion Axes
        const qy    = new Vec3();
        const qz    = new Vec3();

        const rot   = new Quat();   // Main Rotation
        const q     = new Quat();   // Temp Rotation
        const axis  = new Vec3();   
        const v     = new Vec3();   // Temp Vector

        let denom;
        let rad;

        for( let i=0; i < iter; i++ ){
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Get current rotation axes
            qx.fromQuat( rot, Vec3.RIGHT );
            qy.fromQuat( rot, Vec3.UP );
            qz.fromQuat( rot, Vec3.FORWARD );
            
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Compute some kind of scalar
            denom = 1 / Math.abs(
                Vec3.dot( qx, c[0] ) +
                Vec3.dot( qy, c[1] ) +
                Vec3.dot( qz, c[2] )
            ) + 0.00000001 ;

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Compute rotation axis and angle
            axis
                .fromCross( qx, c[0] )
                .add( v.fromCross( qy, c[1] ) )
                .add( v.fromCross( qz, c[2] ) )
                .scale( denom );

            rad = axis.len;
            if( rad < 0.00000001 ) break;

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            q.fromAxisAngle( axis.norm(), rad ).norm();     // Create rotation
            // if( Quat.dot( rot, q ) < 0  ) q.negate();
            rot.pmul( q ).norm();                           // Accumulate rotation
        }

        return rot;
    }
    // #endregion
}


var KabschEnvironment = function () {
  this.pointsRef = Ref.tar;
  this.pointsToMatch = Ref.ref;
  this.curQuaternion = new THREE.Quaternion(0,0,0,1);
  this.numPoints = 4;

  this.rotation = [0,0,0,1];
  this.translation = [0,0,0];

  this.getAverage = function (points) {
    let average = new THREE.Vector3(0, 0, 0);
    let v = new THREE.Vector3();
    for (let i = 0; i < points.length; i++) {
        average.add(v.fromArray( points[i] ));
        // average.add(points[i].position);
    }
    average.divideScalar(points.length);
    return average;
  }

  /* ORIGINAL FROM PDF
  void extractRotation(const Matrix3d &A, Quaterniond &q, const unsigned int maxIter){
    for (unsigned int iter = 0; iter < maxIter; iter++) {
        Matrix3d R = q.matrix();
        
        Vector3d omega = (
            R.col(0).cross(A.col(0)) + 
            R.col(1).cross(A.col(1)) + 
            R.col(2).cross(A.col(2)) ) * 
            
            (
                1.0 / fabs(
                    R.col(0).dot(A.col(0)) + 
                    R.col(1).dot(A.col(1)) + 
                    R.col(2).dot(A.col(2))
                ) + 1.0e-9
            );
        
        double w = omega.norm();
        
        if (w < 1.0e-9) break;
        q = Quaterniond(AngleAxisd(w, (1.0 / w) * omega)) * q;
        q.normalize();
    }
  }
  */

  //https://animation.rwth-aachen.de/media/papers/2016-MIG-StableRotation.pdf
  //Iteratively apply torque to the basis using Cross products (in place of SVD)
  this.quaternionTorqueDecomposition = function (A, curQuaternion, iterations = 9) {
    // Cancels out the momentum from the prior frame
    curQuaternion.copy(new THREE.Quaternion(0,0,0,1));

    let QuatBasis  = [ new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1) ];
    let quatMatrix = new THREE.Matrix4();//.makeRotationFromQuaternion(curQuaternion);
    
    Debug.ln.reset();

    for (let iter = 0; iter < iterations; iter++) {
    //   quatMatrix.makeRotationFromQuaternion(curQuaternion);
    //   quatMatrix.extractBasis(QuatBasis[0], QuatBasis[1], QuatBasis[2]);

      QuatBasis[0].set( 1, 0, 0 ).applyQuaternion( curQuaternion );
      QuatBasis[1].set( 0, 1, 0 ).applyQuaternion( curQuaternion );
      QuatBasis[2].set( 0, 0, 1 ).applyQuaternion( curQuaternion );


    //   Debug.ln.add( [0,0,0], new Vec3( QuatBasis[2].toArray()).scale(4), 0x00ff00 );
      
    //   let omegaDenom = Math.abs(
    //     QuatBasis[0].dot(A[0]) +
    //     QuatBasis[1].dot(A[1]) +
    //     QuatBasis[2].dot(A[2]) + 0.00000001 );
        
        // This one is the correct way the math was written in the PDF
        let omegaDenom = 1 / 
            Math.abs(
                QuatBasis[0].dot(A[0]) +
                QuatBasis[1].dot(A[1]) +
                QuatBasis[2].dot(A[2]) 
            ) + 0.00000001;

        let omega =
            QuatBasis[0].clone().cross( A[0] )
            .add(
                QuatBasis[1].clone().cross( A[1] )
            ).add(
                QuatBasis[2].clone().cross( A[2] )
            ).multiplyScalar( omegaDenom ); //.divideScalar( omegaDenom );
        

        // let omega =
        // A[0].clone().cross( QuatBasis[0] )
        // .add(
        //     A[1].clone().cross( QuatBasis[1] )
        // ).add(
        //     A[2].clone().cross( QuatBasis[2] )
        // ).multiplyScalar( omegaDenom ); //.divideScalar( omegaDenom );

        let w = omega.length()
        // let w = omega.length() * omegaDenom;
        if (w < 0.00000001) { break; }

    //   w = w % ( Math.PI * 2 );
      const rot = new THREE.Quaternion().setFromAxisAngle(omega.normalize(), w).normalize();

      // Test quats for op hemispheres, negate if true
      if( Quat.dot( curQuaternion.toArray(), rot.toArray() ) < 0 ){
        // rot.x = -rot.x;
        // rot.y = -rot.y;
        // rot.z = -rot.z;
        // rot.w = -rot.w;
        // console.log( rot, w );
      }

      curQuaternion.premultiply( rot );
      curQuaternion.normalize(); //Normalizes the Quaternion; critical for error suppression
    }

    // Debug.ln.add( [0,0,0], new Vec3( QuatBasis[2].toArray()).scale(4), 0x00ff00 );
    curQuaternion.normalize()
  }

  this.transposeMult = function(vec1, vec2) {
    let covariance = [ // Initialize Cross Covariance Matrix
      new THREE.Vector3(0, 0, 0), 
      new THREE.Vector3(0, 0, 0), 
      new THREE.Vector3(0, 0, 0)];

    for (let i = 0; i < 3; i++) {               //i is the row in this matrix
      for (let j = 0; j < 3; j++) {             //j is the column in the other matrix
        for (let k = 0; k < vec1.length; k++) { //k is the column in this matrix
          covariance[i].setComponent(j, 
            covariance[i].getComponent(j) + (vec1[k].getComponent(i) * vec2[k].getComponent(j)));
        }
      }
    }
    return covariance;
  }

  this.kabschPoints = function (pointsIn=this.pointsToMatch, pointsRef=this.pointsRef) {
    let workingRef = []; let workingIn = [];
    let refAverage = this.getAverage(pointsRef);
    let inAverage = this.getAverage(pointsIn);

    // Mean-center the points for the optimal translation
    for (let i = 0; i < pointsRef.length; i++) {
    //   workingRef.push(pointsRef[i].position.clone().sub(refAverage));
    //   workingIn.push(pointsIn[i].position.clone().sub(inAverage));

      workingRef.push( new THREE.Vector3().fromArray(pointsRef[i]).sub(refAverage) );
      workingIn.push( new THREE.Vector3().fromArray(pointsIn[i]).sub(inAverage) );
    }

    // Calculate the optimal rotation
    let crossCovarianceMatrix = this.transposeMult(workingIn, workingRef);
    this.quaternionTorqueDecomposition(crossCovarianceMatrix, this.curQuaternion );


    this.rotation = this.curQuaternion.toArray();
    this.translation = refAverage.clone().sub( inAverage ).toArray();

    // Apply the optimal translation and rotation
    for (let i = 0; i < workingIn.length; i++) {
      workingIn[i].applyQuaternion(this.curQuaternion).add( refAverage );
    //   pointsIn[i].position.copy(workingIn[i].add(refAverage));

    //   Debug.pnt.add( workingIn[i].toArray(), 0xffff00, 8, 6 );
    //   Debug.pnt.add( pointsRef[i], 0x00ffff, 8 );
    }
  }

}



</script>
<style>
    .cont{ position:fixed; top:10px; left:10px; font-family:monospace; color:yellow; font-size:14px;}
</style>
<div class="cont">
    Press 1, 2, 3, 4 on keyboard to switch points
</div>
</body></html>