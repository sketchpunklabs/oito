<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';

import { Vec3 }                 from '@oito/oop';
import { Ray, intersectAABB }   from '@oito/ray';
// #endregion

// #region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {
    min : [ 0,0,0 ],
    max : [ 1,1,1 ],
};

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 0, 20, 6 );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    
    Debug.ln.box( Ref.min, Ref.max, 0x909090 );

    // Head&Tail out but passes threw
    const a = [0.5,0.5,2.0];        // [0.3, 0.6]
    const b = [0.5,0.5,-1.0];

    // Head in, Tail Out
    // const a = [0.5,0.5,0.5];     // [-0.3, 0.3]
    // const b = [0.5,0.5,-1.0];

    // Head out, Tail in
    // const a = [0.5,0.5,2.0];     // [0.6, 1.3]
    // const b = [0.5,0.5,0.5];

    // No intersect before cube
    // const a = [0.5,0.5,2.0];     // [2, 4]
    // const b = [0.5,0.5,1.5];

    // No intersect after cube
    // const a = [0.5,0.5,-1.0];       // [-2,-1] 
    // const b = [0.5,0.5,-2.0];

    const hit = segmentAABB( a, b, Ref.min, Ref.max );

    console.log( hit );

    Debug.ln.add( a, b, 0x00ff00, 0xff0000 );
    Debug.pnt.add( a, 0x00ff00, 3 );
    Debug.pnt.add( b, 0xff0000, 3 );

    if( hit ){
        Debug.pnt.add( hit[2], 0xffff00, 3 );
        Debug.pnt.add( hit[3], 0x00ffff, 3 );
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.renderLoop();
});
// #endregion

function pointInAABB( p, min, max ){
    return ( 
        min[ 0 ] <= p[ 0 ] && p[ 0 ] <= max[ 0 ] &&
        min[ 1 ] <= p[ 1 ] && p[ 1 ] <= max[ 1 ] &&
        min[ 2 ] <= p[ 2 ] && p[ 2 ] <= max[ 2 ]
    );
}

/** returns the ray LENGTH, use directionAt() */
function segmentAABB( head, tail, min, max ){
    if( pointInAABB( head, min, max ) ) console.log( 'HEAD IN' );
    if( pointInAABB( tail, min, max ) ) console.log( 'TAIL IN' );

    const tMin = new Vec3( min ).sub( head );
    const tMax = new Vec3( max ).sub( head );
    const dir  = new Vec3( tail ).sub( head );

    tMin.div( dir );
    tMax.div( dir );

    const t1    = new Vec3( tMin ).min( tMax );
    const t2    = new Vec3( tMin ).max( tMax );
    const tNear = Math.max( t1[0], t1[1], t1[2] );
    const tFar  = Math.min( t2[0], t2[1], t2[2] );

    // Extra test where at least 1 side is within 0:1 range
    // If both are outside then the segment doesn't intersect
    // In Terms of a ray there is an intersection
    const rngNear = ( tNear >=0 && tNear <= 1 );
    const rngFar  = ( tFar >=0  && tFar <= 1 );

    if( rngNear || rngFar ) console.log( 'GOOD' );
    else                    console.log( 'EH' );

    return ( tNear < tFar )? [
        tNear, 
        tFar,
        dir.clone().scale( tNear ).add( head ),
        dir.clone().scale( tFar ).add( head ),
    ] : null;
}


/*
int point_aabb( vec3 p, vec3 min, vec3 max ){
    return (
        min.x <= p.x && p.x <= max.x &&
        min.y <= p.y && p.y <= max.y &&
        min.z <= p.z && p.z <= max.z
    )? 1 : 0;
}

int segment_aabb( vec3 head, vec3 tail, vec3 bMin, vec3 bMax ){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Test if either end is inside the box
    if( point_aabb( head, bMin, bMax ) == 1 ) return 1;
    if( point_aabb( tail, bMin, bMax ) == 1 ) return 1;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    vec3 dir    = tail - head;
    vec3 tMin   = ( bMin  - head ) / dir;
    vec3 tMax   = ( bMax  - head ) / dir;
    
    vec3 t1     = min( tMin, tMax );
    vec3 t2     = max( tMin, tMax );
    float tNear = max( max( t1.x, t1.y ), t1.z );
    float tFar  = min( min( t2.x, t2.y ), t2.z );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    
    if( tNear < tFar ){

        // Extra test where at least 1 side is within 0:1 range
        // If both are outside then the segment doesn't intersect
        // In Terms of a ray there is an intersection
        if( 
            ( tNear >=0.0 && tNear <= 1.0 ) ||
            ( tFar  >=0.0 && tFar  <= 1.0 )
        ) return 1;
    }

    return 0;
}
*/

</script></body></html>