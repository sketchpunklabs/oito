<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';

import { Vec3 }                 from '@oito/oop';
import { Ray, intersectSphere, RaySphereResult } from '@oito/ray';
// #endregion

// #region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {
    pos     : [ 0, 1.0, 0 ],
    radius  : 0.5,
};

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 0, 20, 6 );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    
    drawSphere();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.renderLoop();
});
// #endregion

window.addEventListener( 'pointerdown', e=>{
    if( e.button != 2 ) return;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Compute the Ray and visually draw a line
    const ray = from3JSScreenProjection( new Ray(), e.layerX, e.layerY );
    Debug.ln.add( ray.posStart, ray.posEnd, 0x00ffff );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const results = new RaySphereResult();
    if( intersectSphere( ray, Ref.pos, Ref.radius, results ) ){
        Debug.pnt.add( results.posEntry, 0x00ff00, 3 );
        Debug.pnt.add( results.posExit,  0xff0000, 3 );
    }
} );


function from3JSScreenProjection( ray, xMouse, yMouse ){
    const size      = new THREE.Vector2();
    const proj      = App.camera.projectionMatrix.toArray();    // Need Projection Matrix
    const camWorld  = App.camera.matrixWorld.toArray();         // World Space Transform of Camera
    App.renderer.getSize( size );                               // Need Size of Canvas

    // Setup Ray
    ray.fromScreenProjection( xMouse, yMouse, size.x, size.y, proj, camWorld );
    return ray;
}


// #region LOREM

function drawSphere(){
    const verts = sphereVerts( Ref.radius, Ref.pos );
    const apos  = new Vec3().fromBuf( verts, 0 );
    const bpos  = new Vec3();
    for( let i=3; i < verts.length; i+=3 ){
        bpos.fromBuf( verts, i, bpos );
        Debug.ln.add( apos, bpos, 0x00ffff );
        apos.copy( bpos );
    }

    Debug.pnt.add( Ref.pos, 0x00ffff, 2 );
}

function sphereVerts( radius=0.5, offset=[0,0,0] ){
    /*Rotate By Y
    ry = y;
    rx = z*sin + x*cos;
    rz = z*cos - x*sin;
    */
    let vSize		= 7,					// How many points from bottom to top.
        hSize		= 3,					// How many times to rotate the circle
        vInc		= Math.PI / (vSize-1),	// Increment bottom to top
        hInc		= Math.PI / (hSize),	// Increment rotation for each circle created
        vLoopLen	= vSize * 2 - 1,		// Loop size for creating a circle
        half		= Math.PI * 0.5,		// Half of PI, will be origin when creating the circle
        x,
        y,
        r,		// rads for circle rotation
        i,		// loop var for circle making
        rad,	// rads for making the circle
        sin,	// sin of the angle to rotate circle
        cos;	// cos of the angle to rotate circle

    let v = [];
    for( let j=0; j < hSize; j++ ){
        r	= hInc * j - half;
        cos	= Math.cos( r );
        sin	= Math.sin( r );

        for( i=0; i < vLoopLen; i++ ){
            rad	= vInc * i - half;
            x 	= radius * Math.cos( rad );
            y 	= radius * Math.sin( rad );
            v.push( 
                x * cos + offset[ 0 ], 
                y + offset[ 1 ],  
                x * sin + offset[ 2 ],
            );
        }
    }

    return v;
}

// #endregion

</script></body></html>