<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../_lib/useThreeWebGL2.js';

import { Vec3, Transform }                 from '@oito/oop';
import { Ray, intersectCapsule, RayCapsuleResult }   from '@oito/ray';
// #endregion

// #region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {
    posA     : new Vec3( 0,  0.7, 0 ),
    posB     : new Vec3( 0, -0.7, 0 ),
    radius   : 0.5,
};

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 0, 20, 6 );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.transform = new Transform();
    Ref.transform.pos.xyz( 1, 1, -1 );
    Ref.transform.rot.fromEuler( -45, 45, 45 );

    Ref.transform.transformVec3( Ref.posA );
    Ref.transform.transformVec3( Ref.posB );

    drawShape();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.renderLoop();
});
// #endregion

window.addEventListener( 'pointerdown', e=>{
    if( e.button != 2 ) return;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Compute the Ray and visually draw a line
    const ray = from3JSScreenProjection( new Ray(), e.layerX, e.layerY );
    Debug.ln.add( ray.posStart, ray.posEnd, 0x00ffff );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const results = new RayCapsuleResult();
    if( intersectCapsule( ray, Ref.radius, Ref.posA, Ref.posB, results ) ){
        Debug.pnt.add( results.pos, 0x00ff00, 2 );
    }
} );


function from3JSScreenProjection( ray, xMouse, yMouse ){
    const size      = new THREE.Vector2();
    const proj      = App.camera.projectionMatrix.toArray();    // Need Projection Matrix
    const camWorld  = App.camera.matrixWorld.toArray();         // World Space Transform of Camera
    App.renderer.getSize( size );                               // Need Size of Canvas

    // Setup Ray
    ray.fromScreenProjection( xMouse, yMouse, size.x, size.y, proj, camWorld );
    return ray;
}


// #region LOREM

function drawShape(){
    const verts = capsuleVerts( Ref.radius, Ref.posA, Ref.posB );
    const apos  = new Vec3().fromBuf( verts, 0 );
    const bpos  = new Vec3();
    
    Ref.transform.transformVec3( apos );
    for( let i=0; i < verts.length; i+=3 ){
        bpos.fromBuf( verts, i );
        Ref.transform.transformVec3( bpos );

        Debug.ln.add( apos, bpos, 0xffff00 );
        apos.copy( bpos );
    }

    Debug.pnt.add( Ref.posA, 0xffff00, 2 );
    Debug.pnt.add( Ref.posB, 0xffff00, 2 );
}

function capsuleVerts( radius=0.5, vecStart, vecEnd ){
    const PIH    = Math.PI * 0.5;
    const arcSeg = 4;
    const rotSeg = 3;
    const v      = [];
    const hh     = Math.abs( vecEnd[1] - vecStart[1] ) * 0.5;

    let i;
    let rad, x, y, z;

    //.......................................
    // Draw Top Arc
    for( i=0; i <= arcSeg; i++ ){
        rad = PIH - i / arcSeg * PIH;
        x   = radius * Math.cos( rad );
        y   = radius * Math.sin( rad ) + hh;
        v.push( x, y, 0 );
    }

    // Repeat arc in reverse to make bottom half
    for( i=v.length-1; i >=0; i-=3 ){
        v.push( v[ i-2 ], -v[ i-1 ], v[ i ] );
    }

    //.......................................
    // Repeat the capsule half in reverse to build one complete 2D capsule.
    for( i=v.length-6; i > 0; i-=3 ) v.push(-v[i],v[i+1],v[i+2]);

    //.......................................
    // Repeat the 2D Capsule a few times to make it 3D-ish
    const vLen = v.length;
    let cos, sin;
    for( let j=1; j < rotSeg; j++){
        rad = j / rotSeg * Math.PI * 2;
        cos = Math.cos( rad );
        sin = Math.sin( rad );
        for( i=0; i < vLen; i+=3 ) v.push( v[i] * cos, v[i+1], -v[i] * sin );
    }

    //.......................................
    //Final Point to finish up capsule
    v.push( v[0], v[1], v[2] );
    
    return v;
}

// #endregion

</script></body></html>