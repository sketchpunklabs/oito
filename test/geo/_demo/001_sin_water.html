<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
//#region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../../_lib/useThreeWebGL2.js';
import Util         from '../../_lib/misc/Util.js';

import TerrainCube  from '../../../packages/geo/src/3d/specialties/TerrainCube.ts';
//#endregion

//#region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {
    cells: 40,

    rays: [
        [0.3, 2.0, 0.3],
        [1.2, 2.0, 0.7 ],
        [0.9, 2.0, 1.5 ],
    ],
};

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( -30, 40, 6 );
    Debug = await useVisualDebug( App );
    Debug.pnt.useDepth( true );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    let tGeo = TerrainCube.create( { cells: Ref.cells, size:2, height:1, alt:false } );
    let bGeo = Util.geoBuffer( tGeo );
    // let mesh = new THREE.Mesh( bGeo, new THREE.MeshBasicMaterial( { color:0xa0a0a0, flatShading:false, wireframe:false } ) ); //  side:THREE.DoubleSide,

    Ref.mat = CustomMaterial();
    let mesh = new THREE.Mesh( bGeo, Ref.mat );

    App.scene.add( mesh );


    Ref.wave = new SineWave();
    // const p = Ref.wave.getHit( [0.7, 2.0, 1.2] );

    // Debug.pnt.add( p, 0x00ffff, 3 );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // App.renderLoop();
    App.createRenderLoop( onPreRender ).start();
});

function onPreRender( dt, et ){
    et *= 2.5;

    Ref.mat.clock = et;
    drawHit( et );
}

function drawHit( et ){
    Debug.reset();
    const colors = [ 0x00ffff, 0xffff00, 0xff00ff ];

    let hit;
    let col;
    let c = 0;
    for( const r of Ref.rays ){
        col = colors[ c++ ];
        hit = Ref.wave.getHit( r, et );

        Debug.ln.add( r, hit, col );
        Debug.pnt.add( hit, col, 4 );
        Debug.pnt.add( r, col, 5, 11 );
    }
}

// #endregion


// https://github.com/GarrettGunnell/Water
// https://www.youtube.com/watch?v=PH9q0HNBjT4&list=WL&index=16
// WAVE EQUATION :
// phase = speed * ( 2 / wavelength )
// freq  = 2 / wavelength
// h     = amp * sin( x * freq + time * phase )
// h     = amp * e^( sin(x)-1 ) 

function CustomMaterial(){
    const mat = new THREE.RawShaderMaterial({
    depthTest       : true,
    transparent 	: false, 
    uniforms        : { 
        clock       : { value : 0 },

        GridSize    : { value : 2 },
        GridRes     : { value : Ref.cells+1 },
    },
    vertexShader    : `#version 300 es
    in vec3 position;
    in vec3 normal;
    in vec2 uv;
    
    uniform mat4 modelMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;
    
    uniform float clock;

    out vec3 fragNorm;
    out vec3 fragWPos;

    /////////////////////////////////////////////////////////////////
    // #region SIGN WAVE

    struct Wave{
        vec2 dir;
        float freq;
        float speed;
        float steep;
        float amp;
    };

    const int waveCnt = 3;
    Wave[] waves = Wave[](
        Wave( vec2( 0.5, 0.5 ), 0.3, 1.0, 2.0, 0.3 ),
        Wave( vec2( 0.0, 1.0 ), 0.4, 1.0, 1.0, 0.1 ),
        Wave( vec2( 1.0, 0.5 ), 0.6, 1.5, 1.0, 0.06 )
    );

    float sineWave( Wave w, float step, float clock, out vec3 norm ){
        // Sine used for Height & Normal
        float t = step * w.freq + clock * w.speed;
        float s = sin( t ) * 0.5 + 0.5;

        // Compute Normal
        float h = pow( s, max( 1.0, w.steep - 1.0 ) );
        float d = w.steep * w.freq * w.amp * h * cos( t );
        norm   += normalize( vec3( -w.dir.x * d, 1.0, -w.dir.y * d ) );

        // Compute Height
        return w.amp * pow( s, w.steep );
    }

    // float sineWaveV1( Wave w, float step, float clock){
    //     return w.amp * pow( sin( step * w.freq + clock * w.speed ) * 0.5 + 0.5 , w.steep );
    // }

    // vec3 sineWaveNormalV1( Wave w, float step, float clock ){
    //     float h = pow( sin( step * w.freq + w.speed * clock ) * 0.5 + 0.5, max( 1.0, w.steep - 1.0 ) );
    //     float d = w.steep * w.freq * w.amp * h * cos( step * w.freq + clock * w.speed );
    //     vec2  n = -w.dir * d;
    //     return normalize( vec3( n.x, 1.0, n.y ) );
    // }

    // #endregion

    /////////////////////////////////////////////////////////////////
    // #region GRID
    const float FLOOR = 0.001;
    uniform float GridSize;
    uniform float GridRes;

    vec2 gridCoord( vec2 p ){
        float inc = GridSize / GridRes;
        return floor( p / vec2( inc ) );
    }

    vec2 gridCenterCoord( vec2 p ){
        float inc = GridSize / GridRes;
        p += vec2( GridSize * 0.5 );       // Shift so top Left is at origin
        return floor( p / vec2( inc ) );
    }
    
    // #endregion

    /////////////////////////////////////////////////////////////////

    void main(){
        vec3 pos = position;
        fragNorm = normal;

        if( pos.y > FLOOR ){
            float minH = 1.0;
            vec2 coord = gridCoord( pos.xz );
            vec3 norm  = vec3( 0.0 );

            // Wave w      = waves[ 0 ];
            // float step  = dot( coord, normalize( w.dir ) );
            // pos.y       = minH + sineWave( w, step, clock, norm );

            float h = 0.0;
            if( waveCnt > 0 ) h += sineWave( waves[0], dot( coord, normalize( waves[0].dir ) ), clock, norm );
            if( waveCnt > 1 ) h += sineWave( waves[1], dot( coord, normalize( waves[1].dir ) ), clock, norm );
            if( waveCnt > 2 ) h += sineWave( waves[2], dot( coord, normalize( waves[2].dir ) ), clock, norm );

            pos.y = minH + h;

            // Only Apply Wave Normals on top face, use normal to find it
            if( normal.x < 0.001 && normal.z < 0.001 && normal.y > 0.9 ){
                fragNorm = norm;
            }
        }

        vec4 wPos   = modelMatrix * vec4( pos, 1.0 );
        fragWPos    = wPos.xyz;
        gl_Position = projectionMatrix * viewMatrix * wPos;
    }`,

    fragmentShader  : `#version 300 es
    precision mediump float;

    in vec3 fragNorm;
    in vec3 fragWPos;

    uniform vec3 cameraPosition;

    out vec4    outColor;

    ////////////////////////////////////////////////////////////////////////


    ////////////////////////////////////////////////////////////////////////
    const vec3 lightWPos = vec3( 10.0, 10.0, 10.0 );

    void main(){
        // vec3 N = normalize( cross( dFdx(fragWPos), dFdy(fragWPos) ) );
        // vec3 N    = normalize( fragNorm );
        
        float ns  = 4.0; // Normal is to light, scale it up to improve renderering
        vec3 N    = normalize( vec3( fragNorm.x * ns, fragNorm.y, fragNorm.z * ns ) );

        vec3 L    = normalize( lightWPos - fragWPos );
        float NdL = clamp( dot( L, N ), 0.0, 1.0 );

        outColor = vec4( vec3( NdL ), 1.0 );
    }`});

    Object.defineProperty( mat, 'clock', { 
        set: v=>{ mat.uniforms.clock.value = v } 
    });
    
    return mat;
}

import { Vec2 } from "@oito/oop";

class SineWave{
    minH     = 1;
    gridSize = 2;
    gridRes  = Ref.cells + 1;

    waves = [
        { dir:[ 0.5, 0.5 ], freq:0.3, speed:1.0, steep:2.0, amp:0.3 },
        { dir:[ 0.0, 1.0 ], freq:0.4, speed:1.0, steep:1.0, amp:0.1 },
        { dir:[ 1.0, 0.5 ], freq:0.6, speed:1.5, steep:1.0, amp:0.06 },
    ];

    calcWaveH( w, step, clock ){
        // Sine used for Height & Normal
        const t = step * w.freq + clock * w.speed;
        const s = Math.sin( t ) * 0.5 + 0.5;

        // Compute Height
        return w.amp * Math.pow( s, w.steep );
    }

    getHit( p, clock=0 ){
        // [0.7, 2.0, 1.2]
        const coord = this.gridCoord( p );
        const dir   = new Vec2();

        let steps;
        let h = 0;
        for( const w of this.waves ){

            steps = Vec2.dot( coord, dir.fromNorm( w.dir ) );
            h    += this.calcWaveH( w, steps, clock );
        }

        return [ p[0], this.minH + h, p[2] ];
    }

    gridCoord( p ){
        const inc = this.gridSize / this.gridRes;
        return [ p[0] / inc , p[2] / inc ];
    }

}

</script></body></html>