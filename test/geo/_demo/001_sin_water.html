<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
//#region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../../_lib/useThreeWebGL2.js';
import Util         from '../../_lib/misc/Util.js';

import TerrainCube  from '../../../packages/geo/src/3d/specialties/TerrainCube.ts';
//#endregion

//#region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {};

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 0, 40, 5 );
    // Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    let tGeo = TerrainCube.create( { cells: 12, size:2, height:1 } );
    let bGeo = Util.geoBuffer( tGeo );
    let mesh;

    Ref.mat = CustomMaterial();

    mesh = new THREE.Mesh( bGeo, Ref.mat );
    // mesh = new THREE.Mesh( bGeo, new THREE.MeshBasicMaterial( { color:0xa0a0a0, flatShading:false, wireframe:false } ) ); //  side:THREE.DoubleSide,
    App.scene.add( mesh );

    // mesh = new THREE.Mesh( bGeo, new THREE.MeshPhongMaterial( { color:0x000000, flatShading:false, wireframe:true } ) ); //  side:THREE.DoubleSide,
    // App.scene.add( mesh );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.renderLoop();
    App.createRenderLoop( onPreRender ).start();
});

function onPreRender( dt, et ){
    Ref.mat.clock = et;
}

// #endregion



function CustomMaterial(){
    const mat = new THREE.RawShaderMaterial({
    depthTest       : true,
    transparent 	: false, 
    uniforms        : { 
        clock       : { value : 0 },

        GridSize    : { value : 2 },
        GridRes     : { value : 12 },
        GridHeight  : { value : 1 },
    },
    vertexShader    : `#version 300 es
    in vec3 position;
    in vec3 normal;
    in vec2 uv;
    
    uniform mat4 modelMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;
    
    uniform float clock;

    /////////////////////////////////////////////////////////////////
    

    /////////////////////////////////////////////////////////////////
    
    uniform float GridSize;
    uniform float GridRes;

    const float FLOOR = 0.001;

    vec2 gridCenterCoord( vec2 p ){
        float inc = GridSize / GridRes;
        p += vec2( GridSize * 0.5 );       // Shift so top Left is at origin
        return floor( p / vec2( inc ) );
    }

    vec2 gridCoord( vec2 p ){
        float inc = GridSize / GridRes;
        return floor( p / vec2( inc ) );
    }

    out vec3 fragNorm;
    out vec3 fragWPos;

    /////////////////////////////////////////////////////////////////

    void main(){
        vec3 pos = position;
        fragNorm = normal;

        if( pos.y > FLOOR ){
            vec2 coord = gridCoord( pos.xz );
            // pos.y += coord.x * 0.1; // TEST COORDS

            // https://www.youtube.com/watch?v=PH9q0HNBjT4&list=WL&index=16
            // WAVE EQUATION :
            // phase = speed * ( 2 / wavelength )
            // freq  = 2 / wavelength
            // h     = amp * sin( x * freq + time * phase )
            // h     = amp * e^( sin(x)-1 ) 


            vec2 dir   = vec2( 0.5, 0.5 );
            float minH = 0.8;
            float xz   = coord.x * dir.x + coord.y * dir.y; // dot( coord, dir );
            float freq = 1.0;
            float amp  = 0.2;
            float speed = 2.0;
            float steep = 5.0;

            // pos.y = minH + amp * sin( xz * freq + clock * speed ); // w.amplitude * sin(xz * freq + t);   

            // pos.y = minH + 2.0 * amp * pow( (sin( xz * freq + clock * speed ) + 1.0) / 2.0, steep );
            pos.y = minH + 2.0 * amp * pow( sin( xz * freq + clock * speed ) * 0.5 + 0.5 , steep ); // better

        }

        // if( pos.y > FLOOR ){
        //     vec2 grid   = gridCenterCoord( pos.xz );
        //     pos.y       = Height * getWaves( grid * GridFreq, iteration, Clock );

        //     // Only Apply Wave Normals on top face, so if the normal direction is up, has to be top face.
        //     if( normal.x < 0.001 && normal.z < 0.001 && normal.y > 0.9 ){
        //         fragNorm = getWavesNorm( pos.y, grid * GridFreq, 0.001, iteration, Clock, Height );
        //     }
            
        //     /* Blockness, is just a Snap from what I can tell
        //     float Snap = 0.1;
        //     pos.y      = floor( pos.y / Snap ) * Snap;
        //     */
        // }

        vec4 wPos   = modelMatrix * vec4( pos, 1.0 );
        fragWPos    = wPos.xyz;
        gl_Position = projectionMatrix * viewMatrix * wPos;
    }`,

    fragmentShader  : `#version 300 es
    precision mediump float;

    in vec3 fragNorm;
    in vec3 fragWPos;

    uniform vec3 cameraPosition;
    uniform float GridHeight;

    out vec4    outColor;

    ////////////////////////////////////////////////////////////////////////

    vec3 rgb( int c ){
        return vec3(
            float( ( c >> 16 ) & 0xff ) * 0.00392156863,
            float( ( c >> 8 ) & 0xff ) * 0.00392156863,
            float( c & 0xff ) * 0.00392156863
        );
    }

    vec3 color_step_ramp( vec3[5] color, float[5] wgt, float t, float feather, int i ){
        for( i; i > 0; i-- ){
            if( ( wgt[ i ] - feather ) <= t ){
                return mix( 
                    color[ i-1 ], 
                    color[ i ],
                    smoothstep( wgt[ i ] - feather, wgt[ i ] + feather, t )
                );
            }
        }
        return color[ 0 ];
    }

    ////////////////////////////////////////////////////////////////////////

    const vec3 ambient      = vec3( 0.2 );
    const vec3 light_pos    = vec3( 9.0, 8.0, 10.0 );
    const vec3 light_color  = vec3( 1.0, 1.0, 1.0 );
    const vec3	specular_color      = vec3( 1.0, 1.0, 1.0 );
    const float	specular_strength   = 1.0;
    const float	specular_shine      = 32.0;

    void main(){
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Color Ramp based on Vertex Height
        vec3	ramp_col[5] = vec3[]( rgb(0x6b541d), rgb(0x00fdf2), rgb(0xdbb976), rgb(0x17e45d), rgb(0xd0d0d0) );
        float	ramp_wgt[5] = float[]( 0.0, 0.2, 0.5, .7, .95 );
        float tc            = clamp( fragWPos.y / GridHeight, 0.0, 1.0 );
        vec3 base_color     = color_step_ramp( ramp_col, ramp_wgt, tc, 0.1, 4 );

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        vec3 norm     = normalize( cross( dFdx(fragWPos), dFdy(fragWPos) ) );
        // vec3 norm       = normalize( fragNorm );				// Must normalized, Since it has been interpolated
        vec3 dir_light  = normalize( light_pos - fragWPos );	// Direction of light from fragment
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // DIFFUSE LIGHT
        float diff      = max( dot( norm, dir_light ), 0.0 ); 	// Angle between Frag Normal and Light Direction ( 0 to 1 )
        vec3 diffuse    = diff * light_color;					// Use the angle to scale the amount of light to use.
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // SPECULAR LIGHT
        vec3 dir_reflect    = reflect( -dir_light, norm );		// Reflection Dir of Fragment to Light
        vec3 dir_frag_cam   = normalize( cameraPosition - fragWPos );	// Dir from Fragment to Camera
        float specular      = specular_strength * pow( max( dot( dir_frag_cam, dir_reflect ), 0.0 ), specular_shine );
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // OUTPUT
        outColor        = vec4( base_color.rgb * ( ambient + diffuse ), 1.0 );
        outColor.rgb    = mix( outColor.rgb, specular_color, specular );
    }`});

    Object.defineProperty( mat, 'clock', { 
        set: v=>{ mat.uniforms.clock.value = v } 
    });
    
    return mat;
}

</script></body></html>