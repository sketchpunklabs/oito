<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
//#region IMPORTS
import useThreeWebGL2, { useDarkScene, useVisualDebug } from '../../_lib/useThreeWebGL2.js';

// import { Polygon2D } from '../../../packages/geo/src/index.ts';
import { RandomLCG } from '@oito/core';
import { Vec2 }      from '@oito/oop';
//#endregion

//#region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {};

// Gift Wrapping Algorithm
// https://www.youtube.com/watch?v=EDO4Va1aHuE
// https://www.youtube.com/watch?v=YNyULRrydVI
// https://github.com/Liagson/ConcaveHullGenerator
// https://en.wikipedia.org/wiki/Gift_wrapping_algorithm

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 0, 20, 6 );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const rnd    = new RandomLCG();
    const radius = 2;
    const pnts   = [];
    let x, z, v;
    for( let i=0; i < 20; i++ ){
        x = rnd.next() * radius;
        z = rnd.next() * radius;
        v = new Vec2( x, z );

        pnts.push( v );
        Debug.pnt.add( v.toVec3(), 0x00ff00, 3 );
    }

    giftWrappingAlgo( pnts );
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.renderLoop();
    // App.createRenderLoop( onPreRender ).start();
});

//#endregion

function giftWrappingAlgo( pnts ){
    const hull      = [];
    let i           = findLeftMost( pnts );
    let anchor;
    let prev        = new Vec2( pnts[ i ] ).add( [0, -1] ); // Create a vertical initial angle
    let anchorDir   = new Vec2();
    let testDir     = new Vec2();
    let xVal        = -Infinity;
    let iVal        = -1;
    let val;
    let isOk        = false;

    hull.push( pnts[ i ] ); // Save first point to hull
    
    for( let j=0; j < hull.length; j++ ){
        xVal   = -Infinity;
        iVal   = -1;
        anchor = hull[ j ];
        anchorDir.fromSub( anchor, prev ).norm();

        Debug.pnt.add( anchor.toVec3(), 0xff0000, 5 );
        Debug.ln.add( anchor.toVec3(), new Vec2().fromAdd( anchor, anchorDir ).toVec3(), 0xffffff );

        // Test each point against the anchor point
        for( i=0; i < pnts.length; i++ ){
            if( pnts[i] === anchor ) continue; // Skip if anchor

            testDir.fromSub( pnts[i], anchor ).norm();
            val = Vec2.dot( anchorDir, testDir );
            if( val > xVal ){
                iVal = i;
                xVal = val;
            }

            Debug.ln.add( anchor.toVec3(), pnts[i].toVec3(), 0x909090 );
        }

        Debug.pnt.add( pnts[iVal].toVec3(), 0xffff00, 5 );

        // If initial point, We should be done by finding the complete hull
        if( pnts[iVal] === hull[0] ){ isOk = true; break; }

        // Another point found, tack it on the list for another round
        if( iVal !== -1 ){ hull.push( pnts[iVal] ); prev = anchor; }
    }

    console.log( 'IsSuccess', isOk );
}

function findLeftMost( pnts, ignore=-1 ){
    let iMin = -1;
    let xMin = Infinity;
    for( let i=0; i < pnts.length; i++ ){
        if( i !== ignore && pnts[ i ][ 0 ] < xMin ){
            xMin = pnts[ i ][ 0 ];
            iMin = i;
        }
    }
    return iMin;
}

/*
algorithm jarvis(S) is
    // S is the set of points
    // P will be the set of points which form the convex hull. Final set size is i.
    pointOnHull = leftmost point in S // which is guaranteed to be part of the CH(S)
    i := 0
    repeat
        P[i] := pointOnHull
        endpoint := S[0]      // initial endpoint for a candidate edge on the hull
        for j from 0 to |S| do
            // endpoint == pointOnHull is a rare case and can happen only when j == 1 and a better endpoint has not yet been set for the loop
            if (endpoint == pointOnHull) or (S[j] is on left of line from P[i] to endpoint) then
                endpoint := S[j]   // found greater left turn, update endpoint
        i := i + 1
        pointOnHull = endpoint
    until endpoint = P[0]      // wrapped around to first hull point
*/
</script></body></html>