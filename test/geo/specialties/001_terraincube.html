<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script type="module">
//#region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '../../_lib/useThreeWebGL2.js';
import Util         from '../../_lib/misc/Util.js';

import { Cube }     from '../../../packages/geo/src/index.ts';
import Vec3         from '../../../packages/oop/src/Vec3.ts';
import TerrainCube  from '../../../packages/geo/src/3d/specialties/TerrainCube.ts';
//#endregion

//#region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {};

window.addEventListener( 'load', async _=>{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Setup
    App.sphericalLook( 0, 40, 10 );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    const tex  = new THREE.TextureLoader().load( '../../_res/img/checker_map.jpg' );
    tex.flipY  = true;
    tex.wrapS  = THREE.RepeatWrapping;
    tex.wrapT  = THREE.RepeatWrapping;

    let bGeo;
    let mesh;
    let tGeo = TerrainCube.create( { cells: 12, size:2 } );


    // let v = new Vec3();
    // for( let i=0;  i < tGeo.vertices.length; i+=3 ){
    //     v.fromBuf( tGeo.vertices, i );
    //     Debug.pnt.add( v, 0x00ff00, 3 );
    // }

    bGeo = Util.geoBuffer( tGeo );
    mesh = new THREE.Mesh( bGeo, new THREE.MeshBasicMaterial( { color:0xa0a0a0, map:tex, flatShading:false, wireframe:false } ) ); //  side:THREE.DoubleSide,
    App.scene.add( mesh );

    mesh = new THREE.Mesh( bGeo, new THREE.MeshPhongMaterial( { color:0x000000, flatShading:false, wireframe:true } ) ); //  side:THREE.DoubleSide,
    App.scene.add( mesh );


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.renderLoop();
});

// #endregion

import UtilVertices from '../../../packages/geo/src/util/UtilVertices.ts';
import UtilIndices  from '../../../packages/geo/src/util/UtilIndices.ts';

class TerrainCubeXX{

    static create( _props={} ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const props = Object.assign({
            size    : 1,
            height  : 1,
            cells   : 2,
        }, _props );

        const rtn = { vertices:[], indices:[], normals:[], texcoord:[] };

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Create top grid face
        UtilVertices.createGrid( rtn.vertices, props.size, props.size, props.cells, props.cells, false, false );
        UtilIndices.gridAlt( rtn.indices, props.cells, props.cells, 0, 0, true );
        UtilVertices.gridTexcoord( rtn.texcoord, props.cells, props.cells );

        // & move it into height position
        for( let i=1; i < rtn.vertices.length; i+=3 ) rtn.vertices[ i ] = props.height;

        // Create normals
        for( let i=0; i < rtn.vertices.length / 3; i++ ) rtn.normals.push( 0,1,0 );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const edges = UtilVertices.gridEdgeIndices( props.cells, props.cells );

        this.addSide( rtn, edges[0], [-1,0, 0] );
        this.addSide( rtn, edges[1], [ 0,0, 1] );
        this.addSide( rtn, edges[2], [ 1,0, 0] );
        this.addSide( rtn, edges[3], [ 0,0,-1] );
        this.addCap( rtn, edges );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        return rtn;
    }

    static addSide( geo, iAry, norm ){
        const iOffset = geo.vertices.length / 3;
        let ii;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Create Vertices & Normals
        let u=0;
        let uu=0;
        for( let i of iAry ){
            ii = i * 3;
            uu = u++ / ( iAry.length-1 );

            geo.texcoord.push( uu, 1, uu, 0 );
            geo.normals.push( ...norm, ...norm );
            geo.vertices.push(
                geo.vertices[ ii + 0 ], // TOP POINT
                geo.vertices[ ii + 1 ],
                geo.vertices[ ii + 2 ],

                geo.vertices[ ii + 0 ], // BOT POINT
                0,
                geo.vertices[ ii + 2 ],
            );
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Create Indices
        for( let i=0; i < iAry.length-1; i++ ){
            ii = iOffset + i * 2;
            geo.indices.push(
                ii,   ii+1, ii+2,
                ii+2, ii+1, ii+3,
            );
        }
    }

    static addCap( geo, edges ){
        const iOffset = geo.vertices.length / 3;
        const mid     = [0,0];
        let ii;
        let i;
        
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // LEFT SIDE
        for( i=0; i < edges[0].length; i++ ){
            ii        = 3 * edges[0][i];
            mid[ 0 ] += geo.vertices[ ii + 0 ];
            mid[ 1 ] += geo.vertices[ ii + 2 ];

            geo.vertices.push( geo.vertices[ ii + 0 ], 0, geo.vertices[ ii + 2 ] );
            geo.texcoord.push( 0, i / ( edges[0].length - 1) );
            geo.normals.push( 0, -1, 0 );
        }

        // Bottom
        for( i=1; i < edges[1].length; i++ ){
            ii        = 3 * edges[1][i];
            mid[ 0 ] += geo.vertices[ ii + 0 ];
            mid[ 1 ] += geo.vertices[ ii + 2 ];
            geo.vertices.push( geo.vertices[ ii + 0 ], 0, geo.vertices[ ii + 2 ] );
            geo.texcoord.push( i / ( edges[1].length - 1), 1 );
            geo.normals.push( 0, -1, 0 );
        }

        // RIGHT
        for( let i=1; i < edges[2].length; i++ ){
            ii        = 3 * edges[2][i];
            mid[ 0 ] += geo.vertices[ ii + 0 ];
            mid[ 1 ] += geo.vertices[ ii + 2 ];
            geo.vertices.push( geo.vertices[ ii + 0 ], 0, geo.vertices[ ii + 2 ] );
            geo.texcoord.push( 1, 1 - i / ( edges[2].length - 1) );
            geo.normals.push( 0, -1, 0 );
        }

        // TOP
        for( let i=1; i < edges[3].length-1; i++ ){
            ii        = 3 * edges[3][i];
            mid[ 0 ] += geo.vertices[ ii + 0 ];
            mid[ 1 ] += geo.vertices[ ii + 2 ];
            geo.vertices.push( geo.vertices[ ii + 0 ], 0, geo.vertices[ ii + 2 ] );
            geo.texcoord.push(  1 - i / ( edges[3].length - 1), 0 );
            geo.normals.push( 0, -1, 0 );
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Center Point
        const iMid = geo.vertices.length / 3;
        const vCnt = iMid - iOffset;
        mid[ 0 ] /= vCnt;
        mid[ 1 ] /= vCnt;

        geo.vertices.push( mid[0], 0, mid[1] );
        geo.normals.push( 0,-1,0 );
        geo.texcoord.push( 0.5, 0.5 );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Indices
        for( let i=0; i < vCnt; i++ ){
            ii = ( i+1 ) % vCnt;
            geo.indices.push( iOffset + ii, iOffset + i, iMid );
        }
    }

}

</script></body></html>