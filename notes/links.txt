https://glm.g-truc.net/0.9.3/api/a00164.html
https://github.com/g-truc/glm/blob/master/glm/gtx/euler_angles.inl#L219

Cosine Interolation
https://www.youtube.com/watch?v=j155J5x6Pq0


https://github.com/uber-web/math.gl/tree/master/modules/core/src/classes
https://github.com/uber-web/math.gl/blob/master/modules/core/src/classes/euler.ts
https://github.com/uber-web/math.gl/tree/master/modules/culling/src/lib/bounding-volumes

// Some good extra QUAT functions and explaintion
https://theorangeduck.com/page/exponential-map-angle-axis-angular-velocity

https://iquilezles.org/articles/smoothsteps/

Interesting Easing Functions
https://github.com/BabylonJS/Babylon.js/blob/80c65876dbcdf005c12c37d255a1fe020b36b62b/packages/dev/core/src/Animations/easing.ts
https://github.com/BabylonJS/Babylon.js/blob/80c65876dbcdf005c12c37d255a1fe020b36b62b/packages/dev/core/src/Animations/easing.ts#L358
https://github.com/BabylonJS/Babylon.js/blob/80c65876dbcdf005c12c37d255a1fe020b36b62b/packages/dev/core/src/Maths/math.path.ts#L19


// Interpolation Plus other good stuff in the library
https://github.com/juj/MathGeoLib/blob/master/src/Math/Interpolate.h


// Lots of interesting stuff
https://github.com/spite/codevember-2022/blob/main/modules/Maf.js
https://github.com/spite/codevember-2022/blob/main/modules/easings.js


// Swizzle Rotations of Quaternions
https://github.com/FreyaHolmer/Mathfs/blob/446593cea11f7a25b8e73b8398d77f665039bcee/Runtime/Extensions.cs#L159-L177


// An accurate way to get an angle between vector3s
https://github.com/blender/blender/blob/48e60dcbffd86f3778ce75ab67f95461ffbe319c/source/blender/blenlib/intern/math_vector.c#L452
float angle_normalized_v3v3(const float v1[3], const float v2[3])
{
  /* double check they are normalized */
  BLI_ASSERT_UNIT_V3(v1);
  BLI_ASSERT_UNIT_V3(v2);

  /* this is the same as acos(dot_v3v3(v1, v2)), but more accurate */
  if (dot_v3v3(v1, v2) >= 0.0f) {
    return 2.0f * saasin(len_v3v3(v1, v2) / 2.0f);
  }

  float v2_n[3];
  negate_v3_v3(v2_n, v2);
  return (float)M_PI - 2.0f * saasin(len_v3v3(v1, v2_n) / 2.0f);
}
MINLINE float saasin(float fac)
{
  if (UNLIKELY(fac <= -1.0f))  return (float)-M_PI_2;
  else if (UNLIKELY(fac >= 1.0f))  return (float)M_PI_2;
  else return asinf(fac);
}